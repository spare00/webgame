<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Fortress Classic</title>
<style>
  body { background:#111; color:#0f0; text-align:center; font-family:monospace; }
  canvas { background:#000; display:block; margin:10px auto; border:2px solid #0f0; }
</style>
</head>
<body>

<h2>FORTRESS CLASSIC (2P TURN-BASED)</h2>
<div id="info"></div>
<canvas id="game" width="900" height="450"></canvas>

<script>
/* =====================
   ê¸°ë³¸ ì„¤ì •
===================== */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const info = document.getElementById("info");

const gravity = 0.15;
const TANK_HEIGHT = 6;
const GROUND_OFFSET = 2;
const DAMAGE_MULTIPLIER = 1.3;

let wind = 0;
let bullet = null;
let explosion = null;
let deathExplosion = null;

let currentPlayer = 0;
let gameOver = false;
let winner = null;
let gameOverPending = false;
/* =====================
   ì¬ì‹œì‘
===================== */
function resetGame() {
  // ê²Œì„ ìƒíƒœ
  gameOver = false;
  gameOverPending = false;
  winner = null;
  bullet = null;
  explosion = null;
  deathExplosion = null;

  // í„´ ì´ˆê¸°í™”
  currentPlayer = 0;

  // í”Œë ˆì´ì–´ ì´ˆê¸°í™”
  players[0].hp = 100;
  players[1].hp = 100;
  players[0].alive = true;
  players[1].alive = true;

  players[0].angle = 45;
  players[1].angle = 135;
  players[0].power = 9;
  players[1].power = 9;

  // ì§€í˜• ì¬ìƒì„±
  for (let x = 0; x < canvas.width; x++) {
    terrain[x] = 300 + Math.sin(x * 0.01) * 30;
  }

  // íƒ±í¬ ìœ„ì¹˜ ì¬ì •ë ¬ (ë°”ë‹¥ ë°‘ìœ¼ë¡œ ì•ˆ ë‚´ë ¤ê°€ê²Œ)
  players.forEach(p => {
    p.y = Math.min(
      terrain[p.x] - GROUND_OFFSET,
      canvas.height - TANK_HEIGHT
    );
  });

  // ìƒˆ í„´ ì‹œì‘ (ë°”ëŒ í¬í•¨)
  newTurn();
}


/* =====================
   ì‚¬ìš´ë“œ (WebAudio)
===================== */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function tone(freq, start, duration, volume=0.15) {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = "square";
  osc.frequency.value = freq;
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  gain.gain.setValueAtTime(volume, audioCtx.currentTime + start);
  gain.gain.exponentialRampToValueAtTime(
    0.001, audioCtx.currentTime + start + duration
  );
  osc.start(audioCtx.currentTime + start);
  osc.stop(audioCtx.currentTime + start + duration);
}

function fireSound()      { tone(600, 0, 0.15, 0.12); }
function explodeSound()   { tone(120, 0, 0.4, 0.18); }
function finalBoomSound() { tone(60,  0, 1.2, 0.25); }

// ğŸµ ìŠ¹ë¦¬ ë©œë¡œë”” (ìƒìŠ¹)
function victoryMelody() {
  [440, 554, 659, 880].forEach((f,i)=>tone(f, i*0.18, 0.25, 0.18));
}

// ğŸµ íŒ¨ë°° ë©œë¡œë”” (í•˜ê°•)
function defeatMelody() {
  [440, 392, 330, 220].forEach((f,i)=>tone(f, i*0.22, 0.35, 0.18));
}

/* =====================
   ì§€í˜•
===================== */
const terrain = [];
for (let x = 0; x < canvas.width; x++) {
  terrain[x] = 300 + Math.sin(x * 0.01) * 30;
}

/* =====================
   í”Œë ˆì´ì–´
===================== */
const players = [
  { x:120, angle:45,  power:9, hp:100, y:0, alive:true, color:"#f00", name:"PLAYER 1" },
  { x:780, angle:135, power:9, hp:100, y:0, alive:true, color:"#00f", name:"PLAYER 2" }
];

players.forEach(p=>{
  p.y = Math.min(terrain[p.x] - GROUND_OFFSET, canvas.height - TANK_HEIGHT);
});

/* =====================
   í„´
===================== */
function newTurn() {
  wind = +(Math.random()*2 - 1).toFixed(2);
  bullet = null;
  explosion = null;
}
newTurn();

/* =====================
   ë°œì‚¬
===================== */
function fire() {
  const p = players[currentPlayer];
  const rad = p.angle * Math.PI/180;
  bullet = {
    x:p.x, y:p.y,
    vx:Math.cos(rad)*p.power,
    vy:-Math.sin(rad)*p.power
  };
  fireSound();
}

/* =====================
   ì…ë ¥
===================== */
document.addEventListener("keydown", (e) => {

  /* =====================
     ğŸ” R í‚¤ ì¬ì‹œì‘ì€ í•­ìƒ í—ˆìš©
  ===================== */
  if (e.key === "r" || e.key === "R") {
    resetGame();
    return;
  }

  // ê²Œì„ ì¢…ë£Œ ì¤‘ì´ê±°ë‚˜ íƒ„ì´ ë‚ ì•„ê°€ëŠ” ì¤‘ì´ë©´ ì…ë ¥ ë¬´ì‹œ
  if (gameOver || bullet) return;

  const p = players[currentPlayer];
  if (!p.alive) return;

  const ANGLE_STEP = 2;
  const POWER_STEP = 0.5;

  // ğŸ”´ P1: +1 / ğŸ”µ P2: -1
  // (ê°ë„ ì¡°ì‘ì„ ì‹œê°ì ìœ¼ë¡œ ë™ì¼í•˜ê²Œ ë§Œë“¤ê¸° ìœ„í•œ ë³´ì •)
  const angleDir = currentPlayer === 0 ? 1 : -1;

  switch (e.key) {

    /* =====================
       ê°ë„ ì¡°ì ˆ (â¬†â¬‡)
    ===================== */
    case "ArrowUp":
      p.angle = Math.min(
        180,
        Math.max(0, p.angle + ANGLE_STEP * angleDir)
      );
      break;

    case "ArrowDown":
      p.angle = Math.min(
        180,
        Math.max(0, p.angle - ANGLE_STEP * angleDir)
      );
      break;

    /* =====================
       íŒŒì›Œ ì¡°ì ˆ (â¬…â¡, í”Œë ˆì´ì–´ë³„ ë°˜ì „)
    ===================== */
    case "ArrowRight":
      if (currentPlayer === 0) {
        // ğŸ”´ P1: â†’
        p.power = Math.min(15, p.power + POWER_STEP);
      } else {
        // ğŸ”µ P2: â†’
        p.power = Math.max(2, p.power - POWER_STEP);
      }
      break;

    case "ArrowLeft":
      if (currentPlayer === 0) {
        // ğŸ”´ P1: â†
        p.power = Math.max(2, p.power - POWER_STEP);
      } else {
        // ğŸ”µ P2: â† (ìš”ì²­ ì‚¬í•­)
        p.power = Math.min(15, p.power + POWER_STEP);
      }
      break;

    /* =====================
       ë°œì‚¬
    ===================== */
    case " ":
      fire();
      break;
  }
});

/* =====================
   í­ë°œ
===================== */
function explode(x,y) {
  explodeSound();
  const radius = 25;
  explosion = {x,y,r:radius,life:15};

  for (let i=Math.max(0,x-radius); i<Math.min(canvas.width,x+radius); i++) {
    const dy = Math.sqrt(radius*radius - (i-x)**2);
    terrain[i] = Math.max(terrain[i], y+dy);
  }

  players.forEach((p,idx)=>{
    if (!p.alive) return;

    const dist = Math.hypot(p.x-x, p.y-y);
    if (dist<radius) {
      const dmg = Math.floor((radius-dist)*2*DAMAGE_MULTIPLIER);
      p.hp = Math.max(0, p.hp-dmg);
    }

    if (p.hp===0 && p.alive) {
      p.alive=false;
      triggerDeath(p, idx);
    }

    p.y = Math.min(
      terrain[p.x]-GROUND_OFFSET,
      canvas.height-TANK_HEIGHT
    );
  });

  bullet=null;
  if (!gameOverPending) {
    currentPlayer = 1-currentPlayer;
    setTimeout(newTurn,500);
  }
}

/* =====================
   ì‚¬ë§ ì²˜ë¦¬
===================== */
function triggerDeath(p, idx) {
  finalBoomSound();
  deathExplosion = {x:p.x,y:p.y,r:0,life:40};
  winner = idx===0 ? 2 : 1;
  gameOverPending = true;

  setTimeout(()=>{
    gameOver = true;
    victoryMelody();
    defeatMelody();
  }, 900);
}

/* =====================
   ì—…ë°ì´íŠ¸
===================== */
function update() {
  if (bullet) {
    bullet.x += bullet.vx + wind;
    bullet.y += bullet.vy;
    bullet.vy += gravity;

    if (
      bullet.x<0 || bullet.x>=canvas.width ||
      bullet.y>=terrain[Math.floor(bullet.x)]
    ) explode(Math.floor(bullet.x), bullet.y);
  }

  if (explosion && --explosion.life<=0) explosion=null;

  if (deathExplosion) {
    deathExplosion.r += 2;
    if (--deathExplosion.life<=0) deathExplosion=null;
  }
}

/* =====================
   ë Œë”ë§
===================== */
function drawTerrain() {
  ctx.fillStyle="#0f0";
  for (let x=0;x<canvas.width;x++) {
    ctx.fillRect(x,terrain[x],1,canvas.height-terrain[x]);
  }
}

function drawTank(p) {
  if (!p.alive) return;
  ctx.fillStyle=p.color;
  ctx.fillRect(p.x-6,p.y-TANK_HEIGHT,12,TANK_HEIGHT);

  const rad=p.angle*Math.PI/180;
  ctx.strokeStyle=p.color;
  ctx.beginPath();
  ctx.moveTo(p.x,p.y-TANK_HEIGHT);
  ctx.lineTo(
    p.x+Math.cos(rad)*18,
    p.y-TANK_HEIGHT-Math.sin(rad)*18
  );
  ctx.stroke();
}

function drawTrajectory() {
  if (gameOver || bullet) return;
  const p = players[currentPlayer];
  if (!p.alive) return;

  const rad=p.angle*Math.PI/180;
  let x=p.x,y=p.y;
  let vx=Math.cos(rad)*p.power;
  let vy=-Math.sin(rad)*p.power;

  ctx.fillStyle="#444";
  for (let i=0;i<25;i++) {
    x+=vx+wind; y+=vy; vy+=gravity;
    ctx.fillRect(x,y,2,2);
    if (x<0||x>=canvas.width||y>terrain[Math.floor(x)]) break;
  }
}

function drawWind() {
  const cx=canvas.width/2, cy=30;
  ctx.strokeStyle="#0ff"; ctx.lineWidth=2;

  ctx.beginPath();
  ctx.moveTo(cx-60,cy); ctx.lineTo(cx+60,cy); ctx.stroke();

  const len=wind*40;
  ctx.beginPath();
  ctx.moveTo(cx,cy); ctx.lineTo(cx+len,cy); ctx.stroke();

  const d=Math.sign(len)||1;
  ctx.beginPath();
  ctx.moveTo(cx+len,cy);
  ctx.lineTo(cx+len-8*d,cy-5);
  ctx.lineTo(cx+len-8*d,cy+5);
  ctx.fillStyle="#0ff"; ctx.fill();

  ctx.font="14px monospace";
  ctx.textAlign="center";
  ctx.fillText(`WIND ${wind}`,cx,cy-10);
}

function drawUI() {
  const p = players[currentPlayer];

  // ğŸ”§ UI í‘œì‹œìš© ê°ë„ ë³´ì •
  // P1(ë¹¨ê°•): ê·¸ëŒ€ë¡œ
  // P2(íŒŒë‘): 180 - ì‹¤ì œ ê°ë„
  const displayAngle =
    currentPlayer === 0
      ? p.angle
      : 180 - p.angle;

  info.innerHTML = `
    TURN: <span style="color:${p.color}">${p.name}</span> |
    Angle ${displayAngle.toFixed(0)} |
    Power ${p.power.toFixed(1)} |
    HP:
    <span style="color:${players[0].color}">P1 ${players[0].hp}</span> /
    <span style="color:${players[1].color}">P2 ${players[1].hp}</span>
  `;
}

function drawGameOver() {
  if (!gameOver) return;
  ctx.fillStyle="rgba(0,0,0,0.7)";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle="#fff";
  ctx.font="42px monospace";
  ctx.textAlign="center";
  ctx.fillText(
    `PLAYER ${winner} WINS`,
    canvas.width/2,
    canvas.height/2
  );
}

/* =====================
   ë£¨í”„
===================== */
function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawTerrain();
  drawTrajectory();
  players.forEach(drawTank);
  if (bullet) ctx.fillRect(bullet.x,bullet.y,3,3);
  drawWind();
  drawGameOver();
  drawUI();
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>

</body>
</html>

