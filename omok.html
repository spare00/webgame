<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>ì˜¤ëª© 20Ã—20 (3Ã—3 ê¸ˆìˆ˜ ìˆ˜ì • ìµœì¢…)</title>
<style>
body{
  background:#111;color:#fff;
  font-family:system-ui,sans-serif;
  display:flex;flex-direction:column;align-items:center;
  margin-top:20px;
}
canvas{background:#d8b56a;border:3px solid #333;}
#status{margin:10px;}
.turn{font-size:20px;opacity:.4}
.turn.active{opacity:1;font-weight:bold;transform:scale(1.2)}
#turn-black{color:#000;background:#fff;padding:2px 8px;border-radius:6px}
#turn-white{color:#fff;background:#444;padding:2px 8px;border-radius:6px}
#msg{margin:10px;font-size:20px;color:#ffd700}
</style>
</head>

<body>

<h2>ì˜¤ëª© 20 Ã— 20</h2>

<div id="status">
  <span id="turn-black" class="turn active">â— í‘</span>
  <span style="margin:0 10px;">vs</span>
  <span id="turn-white" class="turn">â— ë°±</span>
</div>

<div id="msg"></div>

<div id="score" style="margin:10px;font-size:18px;">
  í‘ <span id="score-black">0</span> : <span id="score-white">0</span> ë°±
</div>

<button onclick="resetGame()">ë‹¤ì‹œ ì‹œì‘</button><br>
<div id="timer" style="font-size:22px;margin:10px;color:#00ffcc;">
  â± 10
</div>

<canvas id="board" width="600" height="600"></canvas>

<script>
/* ===== ê¸°ë³¸ ì„¤ì • ===== */
const SIZE=20, CELL=30, R=12;
const BLACK=1, WHITE=2;

const canvas=document.getElementById("board");
const ctx=canvas.getContext("2d");
const blackEl=document.getElementById("turn-black");
const whiteEl=document.getElementById("turn-white");
const msg=document.getElementById("msg");

function startTurnTimer(){
  clearInterval(timerId);
  turnTime = 10;
  updateTimerUI();

  timerId = setInterval(()=>{
    turnTime--;
    updateTimerUI();

    if(turnTime <= 0){
      clearInterval(timerId);
      handleTimeoutLoss();
    }
  },1000);
}

function stopTurnTimer(){
  clearInterval(timerId);
  timerId = null;
}

function updateTimerUI(){
  const t = document.getElementById("timer");
  t.textContent = "â± " + turnTime;
  t.style.color = turnTime <= 3 ? "#ff4444" : "#00ffcc";
}

function handleTimeoutLoss(){
  if(gameOver) return;

  stopTurnTimer();
  playTimeoutWinSound();

  const winner = (current === BLACK) ? WHITE : BLACK;

  if(winner === BLACK){
    scoreBlack++;
    msg.textContent = "ì‹œê°„ ì´ˆê³¼! í‘ ìŠ¹ë¦¬!";
  } else {
    scoreWhite++;
    msg.textContent = "ì‹œê°„ ì´ˆê³¼! ë°± ìŠ¹ë¦¬!";
  }

  updateScore();
  gameOver = true;
}

/* ===== ì‚¬ìš´ë“œ ===== */
const AudioCtx=window.AudioContext||window.webkitAudioContext;
const audioCtx=new AudioCtx();
function playStone(){
  const o=audioCtx.createOscillator(),g=audioCtx.createGain();
  o.type="square";o.frequency.value=300;
  g.gain.value=0.05;
  o.connect(g);g.connect(audioCtx.destination);
  o.start();o.stop(audioCtx.currentTime+0.06);
}

function playWinSound(){
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();

  o.type = "triangle";
  o.frequency.setValueAtTime(440, audioCtx.currentTime);
  o.frequency.linearRampToValueAtTime(880, audioCtx.currentTime + 0.25);

  g.gain.value = 0.08;

  o.connect(g);
  g.connect(audioCtx.destination);

  o.start();
  o.stop(audioCtx.currentTime + 0.3);
}

function playTimeoutWinSound(){
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();

  // ê¸´ì¥ê° ìˆëŠ” "ì‹œê°„ ì´ˆê³¼" ëŠë‚Œ
  o.type = "square";
  o.frequency.setValueAtTime(600, audioCtx.currentTime);
  o.frequency.exponentialRampToValueAtTime(120, audioCtx.currentTime + 0.5);

  g.gain.setValueAtTime(0.12, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);

  o.connect(g);
  g.connect(audioCtx.destination);

  o.start();
  o.stop(audioCtx.currentTime + 0.55);
}

/* ===== ìƒíƒœ ===== */
let board,current,gameOver;
let hover=null;
let scoreBlack = 0;
let scoreWhite = 0;
let turnTime = 10;
let timerId = null;


/* ===== ì´ˆê¸°í™” ===== */
function resetGame(){
  stopTurnTimer();
  board=Array.from({length:SIZE},()=>Array(SIZE).fill(0));
  current=BLACK;
  gameOver=false;
  hover=null;
  msg.textContent="";
  updateTurn();
  draw();
  updateScore();
  startTurnTimer();
}
resetGame();

function updateTurn(){
  blackEl.classList.toggle("active",current===BLACK);
  whiteEl.classList.toggle("active",current===WHITE);
}

function updateScore(){
  document.getElementById("score-black").textContent = scoreBlack;
  document.getElementById("score-white").textContent = scoreWhite;
}

function playForbiddenSound(){
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();

  o.type = "sawtooth";
  o.frequency.setValueAtTime(180, audioCtx.currentTime);
  o.frequency.linearRampToValueAtTime(90, audioCtx.currentTime + 0.15);

  g.gain.value = 0.08;

  o.connect(g);
  g.connect(audioCtx.destination);

  o.start();
  o.stop(audioCtx.currentTime + 0.18);
}

/* ===== ê·¸ë¦¬ê¸° ===== */
function draw(){
  ctx.clearRect(0,0,600,600);
  ctx.strokeStyle="#333";

  for(let i=0;i<SIZE;i++){
    ctx.beginPath();
    ctx.moveTo(CELL/2,CELL/2+i*CELL);
    ctx.lineTo(CELL/2+(SIZE-1)*CELL,CELL/2+i*CELL);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(CELL/2+i*CELL,CELL/2);
    ctx.lineTo(CELL/2+i*CELL,CELL/2+(SIZE-1)*CELL);
    ctx.stroke();
  }

  for(let y=0;y<SIZE;y++)
    for(let x=0;x<SIZE;x++)
      if(board[y][x]) drawStone(x,y,board[y][x]);

  // ê¸ˆìˆ˜ hover í‘œì‹œ
  if(hover && isForbiddenMove(hover.y,hover.x,current)){
    ctx.fillStyle="red";
    ctx.beginPath();
    ctx.arc(CELL/2+hover.x*CELL,CELL/2+hover.y*CELL,5,0,Math.PI*2);
    ctx.fill();
  }
}

function drawStone(x,y,c){
  ctx.beginPath();
  ctx.arc(CELL/2+x*CELL,CELL/2+y*CELL,R,0,Math.PI*2);
  ctx.fillStyle=c===BLACK?"#000":"#fff";
  ctx.fill();ctx.stroke();
}

/* ===== ì…ë ¥ ===== */
canvas.addEventListener("mousemove",e=>{
  if(gameOver){hover=null;draw();return;}
  const r=canvas.getBoundingClientRect();
  const x=Math.floor((e.clientX-r.left)/CELL);
  const y=Math.floor((e.clientY-r.top)/CELL);
  hover=(x>=0&&y>=0&&x<SIZE&&y<SIZE&&board[y][x]===0)?{x,y}:null;
  draw();
});
canvas.addEventListener("mouseleave",()=>{hover=null;draw();});



canvas.addEventListener("click", e => {
  // ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ í™œì„±í™” (ë¸Œë¼ìš°ì € ì •ì±… ëŒ€ì‘)
  if (audioCtx.state === "suspended") {
    audioCtx.resume();
  }

  if (gameOver) return;

  const rect = canvas.getBoundingClientRect();
  const x = Math.floor((e.clientX - rect.left) / CELL);
  const y = Math.floor((e.clientY - rect.top) / CELL);

  if (x < 0 || y < 0 || x >= SIZE || y >= SIZE) return;
  if (board[y][x] !== 0) return;

  // ğŸš« ê¸ˆìˆ˜ íŒì • (í‘/ë°± ë™ì¼ ì ìš©)
  if (isForbiddenMove(y, x, current)) {
    playForbiddenSound();   // ğŸ”Š ê¸ˆìˆ˜ íš¨ê³¼ìŒ
    return;                 // ì°©ìˆ˜ ë¬´íš¨
  }

  stopTurnTimer();

  // âœ… ì •ìƒ ì°©ìˆ˜
  board[y][x] = current;

  const maxL = getMaxLine(y, x, current);

  playStone();
  draw();

  // ğŸ† ìŠ¹ë¦¬ íŒì •
  // ì¥ëª©ì€ ê¸ˆìˆ˜ì´ë¯€ë¡œ, ì—¬ê¸°ì„œëŠ” ì •í™•íˆ 5ëª©ë§Œ ìŠ¹ë¦¬ë¡œ ì²˜ë¦¬
  if (maxL === 5) {
    stopTurnTimer();
    playWinSound();

    if(current === BLACK){
      scoreBlack++;
      msg.textContent = "í‘ ìŠ¹ë¦¬!";
    } else {
      scoreWhite++;
      msg.textContent = "ë°± ìŠ¹ë¦¬!";
    }

    updateScore();
    gameOver = true;
    return;
  }

  // ğŸ”„ í„´ êµì²´
  current = (current === BLACK) ? WHITE : BLACK;
  updateTurn();
  startTurnTimer();
});

/* ===== ìŠ¹ë¦¬/ë¼ì¸ ===== */
function getMaxLine(r,c,p){
  const dirs=[[1,0],[0,1],[1,1],[1,-1]];
  let max=1;
  for(const[dr,dc]of dirs){
    let cnt=1;
    let rr=r+dr,cc=c+dc;
    while(rr>=0&&cc>=0&&rr<SIZE&&cc<SIZE&&board[rr][cc]===p){
      cnt++;rr+=dr;cc+=dc;
    }
    rr=r-dr;cc=c-dc;
    while(rr>=0&&cc>=0&&rr<SIZE&&cc<SIZE&&board[rr][cc]===p){
      cnt++;rr-=dr;cc-=dc;
    }
    max=Math.max(max,cnt);
  }
  return max;
}

/* ===================================================
   âœ… ê¸ˆìˆ˜ë£° (í‘/ë°± ë™ì¼ ì ìš©)
   - ê¸ˆìˆ˜: ìŒì‚¼(3Ã—3) + ì¥ëª©(6ëª©â†‘)
   - 4Ã—3(ì‚¬ì‚¼)ì€ í•­ìƒ í—ˆìš©

   âœ… ëŒ€í‘œë‹˜ ê·œì¹™ ë°˜ì˜:
   - "3"ì€ **ëŠê¹€ ì—†ì´ ì§ì ‘ ì—°ê²°ëœ 3**ë§Œ ì¸ì •í•©ë‹ˆë‹¤.
     (ì˜ˆ: 01110 í˜•íƒœì˜ 'ì—°ì† 3' + ì–‘ëì´ ë¹ˆì¹¸)
   - 010110 ê°™ì€ 'ëŠê¸´ 3(ì í”„3)'ì€ 3ìœ¼ë¡œ ë³´ì§€ ì•ŠìŠµë‹ˆë‹¤. (ëŒ€í‘œë‹˜ ê¸°ì¤€: 4ìª½ ì„±ê²©)
=================================================== */

function countConsecutive(r, c, dr, dc, player){
  let n = 0;
  let rr = r + dr, cc = c + dc;
  while(rr>=0 && cc>=0 && rr<SIZE && cc<SIZE && board[rr][cc] === player){
    n++;
    rr += dr; cc += dc;
  }
  return n;
}

// âœ… "ì§ì ‘ ì—°ê²°ëœ ì—´ë¦° 3" (ì—°ì† 3 + ì–‘ëì´ ë¹„ì–´ìˆìŒ)
function isOpenThreeDirConnected(r, c, dr, dc, player){
  const a = countConsecutive(r, c, dr, dc, player);
  const b = countConsecutive(r, c, -dr, -dc, player);
  const total = 1 + a + b;

  if(total !== 3) return false; // ëŠê¸´3/4/2 ë“±ì€ ì œì™¸

  const end1r = r + (a + 1) * dr, end1c = c + (a + 1) * dc;
  const end2r = r - (b + 1) * dr, end2c = c - (b + 1) * dc;

  // ì–‘ëì´ ëª¨ë‘ "ë³´ë“œ ì•ˆ" + "ë¹ˆì¹¸"ì´ì–´ì•¼ ì—´ë¦°3
  if(end1r < 0 || end1c < 0 || end1r >= SIZE || end1c >= SIZE) return false;
  if(end2r < 0 || end2c < 0 || end2r >= SIZE || end2c >= SIZE) return false;
  if(board[end1r][end1c] !== 0) return false;
  if(board[end2r][end2c] !== 0) return false;

  return true;
}

function countOpenThreeDirsFromMove(r, c, player){
  const dirs = [[0,1],[1,0],[1,1],[1,-1]];
  let cnt = 0;
  for(const [dr, dc] of dirs){
    if(isOpenThreeDirConnected(r, c, dr, dc, player)) cnt++;
  }
  return cnt; // ë°©í–¥ ê¸°ì¤€ ì—´ë¦°3 ê°œìˆ˜
}

// âœ… í‘/ë°± ë™ì¼ ê¸ˆìˆ˜ë£°: (ìŒì‚¼) ë˜ëŠ” (ì¥ëª©=6ëª© ì´ìƒ)
function isForbiddenMove(r, c, player){
  if(board[r][c] !== 0) return false;

  board[r][c] = player;

  const maxL = getMaxLine(r, c, player);
  const open3Dirs = countOpenThreeDirsFromMove(r, c, player);

  board[r][c] = 0;

  return (maxL >= 6 || open3Dirs >= 2);
}

</script>

</body>
</html>

